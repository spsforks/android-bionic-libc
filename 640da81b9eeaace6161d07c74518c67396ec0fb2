{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "62a1306b_5a742533",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-09T19:52:53Z",
      "side": 1,
      "message": "do we actually need two different libraries? can\u0027t we just have one and let the linker gc the unused stuff?",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05edabc4_f4e33aa5",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-12-11T11:26:07Z",
      "side": 1,
      "message": "I guess that\u0027s probably because we have our own version of some libc symbols like malloc, free, errno, etc.",
      "parentUuid": "62a1306b_5a742533",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be94635c_8352fd34",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2022-12-12T12:04:10Z",
      "side": 1,
      "message": "Note the difference in `visibility`: `vmbase` acts as a common base library for baremetal Rust projects (and tests) intended to run in Android virtual machines while `pvmfw` is one particular project (uses `vmbase` under the hood) that has extra C dependencies due to it being linked with baremetal C libraries.",
      "parentUuid": "05edabc4_f4e33aa5",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e79da73_cfa1324a",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-12T16:27:05Z",
      "side": 1,
      "message": "\u003e I guess that\u0027s probably because we have our own version of some libc symbols like malloc, free, errno, etc.\n\nno, i don\u0027t mean _all_ of libc ... i mean \"why libc_baremetal_rust_deps and libc_libpvmfw_deps?\"\n\n\u003e Note the difference in visibility: vmbase acts as a common base library for baremetal Rust projects (and tests) intended to run in Android virtual machines while pvmfw is one particular project (uses vmbase under the hood) that has extra C dependencies due to it being linked with baremetal C libraries.\n\nbut why is that a distinction worth making? it\u0027s extra complexity on this side --- what justifies that on the caller side? i\u0027d rather juat have one baremetal rust library.\n\n(as a nit, \"_deps\" is a weird thing to say in the build system, where \"dependencies\" means something else entirely. just use the more traditional \"librust_baremetal\" instead?)",
      "parentUuid": "be94635c_8352fd34",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f36ff21d_a5160ef5",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-12-13T02:53:37Z",
      "side": 1,
      "message": "I am not Pierre, but I felt that he tried to not add \"random stuffs that happen to be needed by pvmfw\" to libc_baremetal_rust_deps which could be used by other baremetal Rust projects.\n\nAnd I agree with you Eliott. _deps is not a good name for these.",
      "parentUuid": "5e79da73_cfa1324a",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72479501_4f18849b",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2022-12-13T14:18:48Z",
      "side": 1,
      "message": "\u003e why is that a distinction worth making?\n\nBecause `baremetal_rust` is the bare minimum required by any baremetal Rust project (as the compiler assumes that `memcpy`, `memset`, and `memcmp` are valid symbols the linker will resolve) while `libpvmfw` provides the symbols that are expected by the (mostly baremetal) C libraries `pvmfw` links against (`libfdt`, `libavb`, `open-dice`) e.g. `__memcpy_chk` or `strtoul`, which aren\u0027t necessarily needed by Rust projects.\n\n\u003e it\u0027s extra complexity on this side --- what justifies that on the caller side? i\u0027d rather juat have one baremetal rust library.\n\nThat\u0027s understandable but would mean that any libc function added for one Rust project would be used by all Rust projects, with the risk of symbols clashing; see [qwandor\u0027s concern on a related CL](https://android-review.git.corp.google.com/c/platform/packages/modules/Virtualization/+/2338645/comments/b6ea6786_f99619cb).\n\n\u003e just use the more traditional \"librust_baremetal\" instead?\n\nDone (here and in aosp/2337444 and aosp/2338645).",
      "parentUuid": "5e79da73_cfa1324a",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5630a23d_be5192ff",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-13T16:34:46Z",
      "side": 1,
      "message": "okay, so the distinction is \"needed by the rust runtime\" vs \"needed by libraries that we happen to be using\". that\u0027s less bad than \"libc_libpvmfw\" which looks to me like the start of the long slippery slope to \"three hundred different libc subsets\".\n\nwhat\u0027s the typical rust solution to this? surely a C library that happens to get linked to rust can have _arbitrary_ libc dependencies? why isn\u0027t pvmfw linking against libc proper, since it\u0027s using C libraries that use libc?\n\n\u003e That\u0027s understandable but would mean that any libc function added for one Rust project would be used by all Rust projects\n\n(which is fine, libc is meant for everyone.)\n\n\u003e with the risk of symbols clashing; see qwandor\u0027s concern on a related CL.\n\ni\u0027m not yet convinced that\u0027s a legitimate concern... \"you\u0027re pulling in C libraries, you\u0027re going to get some libc on you\" :-) (a corollary of which is probably \"you might want to avoid using C names yourself\". rust mangles names anyway, right, so you\u0027d have to be _trying_ to collide?)",
      "parentUuid": "72479501_4f18849b",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0551f40_119f4476",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2022-12-13T17:59:33Z",
      "side": 1,
      "message": "\u003e what\u0027s the typical rust solution to this?\n\nI\u0027d say that the typical case is a userspace program, where we can simply link against the system library. But in the case of pvmfw, we\u0027re combining linking Rust against C (against libc) with the baremetal (\"`no_std`\") constraint.\n\n\u003e why isn\u0027t pvmfw linking against libc proper, since it\u0027s using C libraries that use libc?\n\nI suppose that, in our case, the right approach would be to link against a baremetal implementation of (a subset of) libc but, AFAIK, we don\u0027t have that in AOSP (right?). So, instead, `libpvmfw` also needs to make sure that it doesn\u0027t bring with it some userspace code (e.g. `__errno`) and we can\u0027t simply link against Bionic. Hence the careful carve out I currently have and implementing functions that, in turn, are expected by Bionic (e.g. aosp/2338644).\n\nHow would you recommend we address this?\n\n\u003e rust mangles names anyway, right, so you\u0027d have to be trying to collide?\n\nYou\u0027re right, that\u0027s a good point.",
      "parentUuid": "5630a23d_be5192ff",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "511ae096_da8b9e7f",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-13T19:30:08Z",
      "side": 1,
      "message": "\u003e I\u0027d say that the typical case is a userspace program, where we can simply link against the system library. But in the case of pvmfw, we\u0027re combining linking Rust against C (against libc) with the baremetal (\"no_std\") constraint.\n\ni\u0027m still not sure i\u0027ve really understood what\u0027s going on here ... if you\u0027re going to link against libc in the end (for the C libraries), why do you need another subset?\n\n\u003e I suppose that, in our case, the right approach would be to link against a baremetal implementation of (a subset of) libc but, AFAIK, we don\u0027t have that in AOSP (right?).\n\ncorrect[1], that\u0027s what we\u0027re adding here. for me the two questions are:\n\n1. do we _really_ need anything other than \"real baremetal\" (basically just the mem* functions) and \"full libc\" (for stuff that\u0027s actually pulling in C libraries)?\n\n2. if we do need the third \"libc subset\", what exactly is in it, and why? (and, more informatively, what _isn\u0027t_ in it, and why _not_, since that\u0027s probably the best motivating answer to \"why do we even need this\"?)\n\n\u003e So, instead, libpvmfw also needs to make sure that it doesn\u0027t bring with it some userspace code (e.g. __errno)\n\nsee, i don\u0027t really believe this. not least because the one file you\u0027ve added to this library uses errno:\n\nhttps://source.corp.google.com/android/bionic/libc/bionic/strtol.cpp;l\u003d42?q\u003dfile:strtol.cpp\u0026sq\u003dpackage:%5Eandroid$%20-file:prebuilts%2Fvndk%2F%20-file:prebuilts%2Fruntime%2F\n\nbut even if you\u0027re trying to say \"we don\u0027t want the _definition_ of errno, only the uses\" --- really? who\u0027s providing errno then? and why is that right? (and if they think they\u0027re the C library, providing errno, why aren\u0027t they also providing strtol?)\n\n\u003e and we can\u0027t simply link against Bionic. Hence the careful carve out I currently have and implementing functions that, in turn, are expected by Bionic (e.g. aosp/2338644).\n\nas you can see, i still have my doubts about whether this is really true or not, but if we assume for the sake of argument that it is, i still think we should have exactly one of these \"rust libc subset\" libraries, not one per user (as you appear to be proposing at the moment).\n\n____\n1. funnily enough, we _kind of_ have something like this already. if you look at the .a files in the libc Android.bp that have `_ndk` in the name, you\u0027ll see comments like `// libc_openbsd_ndk.a - upstream OpenBSD C library code that\ncan be safely included in the libc_ndk.a (doesn\u0027t contain any\ntroublesome global data or constructors)`.\nthat didn\u0027t actually go anywhere in the end, but that was a similar principle of \"bits of libc that you could graft into a program to use in preference to the libc.so that you\u0027re inheriting from the system _without_ the two conflicting\". but, as you can see above, i still haven\u0027t understood what (if any) real conflict you actually have in your rust-based world. but once we know what is/isn\u0027t actually safe, then we can collect the safe stuff in one bucket^Wlibrary, and anyone who needs this can use it, without having to reinvent the wheel.",
      "parentUuid": "e0551f40_119f4476",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8409d857_d21cfa85",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2022-12-14T12:03:21Z",
      "side": 1,
      "message": "\u003e as you can see above, i still haven\u0027t understood what (if any) real conflict you actually have in your rust-based world.\n\nSorry I wasn\u0027t clear about this; overall, conflicts don\u0027t really come from using Rust but from running baremetal code that needs some libc functions and trying to  get those from Bionic. The Rust aspect is that, unlike typical baremetal C projects (e.g. Linux, Little Kernel, U-Boot, ...) that use the same C libraries, we aren\u0027t shipping our own implementation of those libc functions and don\u0027t really want to.\n\n\u003e we can collect the safe stuff in one library, and anyone who needs this can use it, without having to reinvent the wheel.\n\nAFAIU, I think that we agree that we would want 2 versions of Bionic:\n\n- the one that currently exists and which relies on the assumption that it is running in the userspace of a standard Linux (POSIX?) environment, and that implements the whole C Standard Library (and more)\n- and a \"baremetal\" one that would only implement the parts of libc (and more) that do not need to make extra assumptions about the environment beyond the CPU architecture and features that can be directly detected through CPU instructions (SIMD, FPU, timer, ...). For example, `FILE*` and the `f`-functions, `abort`, `puts`, or any other function that relies on OS abstractions and syscalls can\u0027t be implemented in an environment-agnostic way and therefore wouldn\u0027t be provided by that library. However, this environment-agnostic subset of libc could be much larger than the `mem*` functions: `string.h` and other `str*` functions, `ato*` and other `stdlib.h` functions (`qsort`, `bsearch`, `abs`, ...), the `w*` multi-byte functions, `printf` (relying on an undefined `puts`) and even more exotic things like `time.h` (at least, on arm64) could all be provided by that library.\n\nAny baremetal AOSP project (Rust or not) needing libc functions would then link against the latter combined (if necessary) with an environment-specific implementation of the remaining symbols (`abort`, `puts`, ...). Actually, this approach could even be used to build the userspace variant!\n\nIMO, extracting the baremetal subset of Bionic into its own library (which, as you said, I\u0027m in a way starting to do here) would be by far the cleanest approach but that sounds (to me) like a daunting task... Is this something you could help with? Until then, could this CL be merged as a temporary way to resolve those dependencies, knowing that the single \"baremetal Bionic\" library is coming?",
      "parentUuid": "511ae096_da8b9e7f",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b7f246b_c76c57c3",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-14T22:53:11Z",
      "side": 1,
      "message": "\u003e AFAIU, I think that we agree that we would want 2 versions of Bionic:\n\nwell, that\u0027s actually _my_ preference, but i thought you were proposing 3 versions:\n\n1. the default \"all the stuff\" libc.so\n2. the \"real baremetal\" that\u0027s just the memory routines.\n3. the \"baremetal, but we\u0027re sneakily running a bit of C code\" that\u0027s ... ?\n\n#3 is the one that\u0027s confused me so far, and is the one that corresponds to \"libc_libpvmfw\".\n\nbut from your _two_ examples, it actually sounds like we might be in \"violent agreement\" here? because, yes (in case i haven\u0027t been clear so far), \"merge libc_libpvmfw into librust_baremetal (rather than having two separate libraries, as in this change) and i\u0027ll +2 without a second thought\". that seems like _obviously_ a good idea.\n\n\u003e IMO, extracting the baremetal subset of Bionic into its own library (which, as you said, I\u0027m in a way starting to do here) would be by far the cleanest approach but that sounds (to me) like a daunting task... Is this something you could help with? Until then, could this CL be merged as a temporary way to resolve those dependencies, knowing that the single \"baremetal Bionic\" library is coming?\n\noh maybe this is the source of the confusion? to be clear, i wasn\u0027t saying \"we need to work out what that _entire_ subset is and get it right first time\". that would indeed be a huge PITA for no immediate benefit. no, my goal is more \"we should have \u0027one true\u0027 library of rust baremetal libc bits that can asymptotically _approach_ that point\". (versus every single rust baremetal project having its own custom subset, as if we don\u0027t trust the linker to discard any functions that are unused :-) )\n\n(sorry if i made this more confusing by talking about the `libndk` stuff yesterday --- my point there was simply analogy, not a recommendation.)",
      "parentUuid": "8409d857_d21cfa85",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9daba4fd_2c402cd7",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2296,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2023-01-03T20:02:23Z",
      "side": 1,
      "message": "As discussed offline, I\u0027ve grouped these into a single `librust_baremetal` library, to be used by (Rust) baremetal AOSP projects.",
      "parentUuid": "5b7f246b_c76c57c3",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b4b6810_92ea1fa2",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2303,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2022-12-12T16:27:24Z",
      "side": 1,
      "message": "(this isn\u0027t needed any more.)",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53956d3f_3eec562d",
        "filename": "libc/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 2303,
      "author": {
        "id": 1882526
      },
      "writtenOn": "2022-12-13T14:18:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3b4b6810_92ea1fa2",
      "revId": "640da81b9eeaace6161d07c74518c67396ec0fb2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}