{
  "comments": [
    {
      "key": {
        "uuid": "f183336d_e8bbf895",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 234,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "seems unnecessary.",
      "range": {
        "startLine": 233,
        "startChar": 0,
        "endLine": 234,
        "endChar": 16
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32bf91bc_54c0cb71",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 234,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "Removed",
      "parentUuid": "f183336d_e8bbf895",
      "range": {
        "startLine": 233,
        "startChar": 0,
        "endLine": 234,
        "endChar": 16
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9df08bda_db5484a6",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You should probably do a __builtin_add_overflow just in case. Otherwise, this could overflow and pass when it really would have failed. It\u0027s probably very unlikely to overflow without triggering some other overflow condition though.",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c5a3e3e_bb28245f",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "if this is speculative, you could use memory_order_relaxed here.  if you like more accuracy, you could use memory_order_acquire.\n\nsize_t temp;\nreturn !builtin_add_overflow(atomic_load_explicit(\u0026gAllocated, memory_order_acquire), bytes, \u0026temp) \u0026\u0026 temp \u003c\u003d gAllocLimit;",
      "parentUuid": "9df08bda_db5484a6",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccd39576_edcb03f5",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "It\u0027s fine for this to be less accurate, I think. We\u0027re already forced to be rather inaccurate as a result of relying on malloc_usable_size which we can only query after an allocation.\n\nRegarding overflow, it seems like in any situation where this would overflow (except in the realloc case discussed below) the allocator *must* fail since it would otherwise need to allocate more than the size of the available address space. And that would result in the intended behaviour.",
      "parentUuid": "7c5a3e3e_bb28245f",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d8fcac95_c753f815",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T21:53:26Z",
      "side": 1,
      "message": "sgtm. unsigned integer overflow is not undefined behavior, unless we tell Clang to sanitize it as such :-).  could use acquire-release atomicity, but sequentially consistent is fine.",
      "parentUuid": "ccd39576_edcb03f5",
      "range": {
        "startLine": 235,
        "startChar": 9,
        "endLine": 235,
        "endChar": 56
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56589881_b2a43825",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "You probably want to check for an overflow condition.",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5eee4212_51bb04c1",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "shouldn\u0027t overflow as is size_t",
      "parentUuid": "56589881_b2a43825",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ac7aeca_6f9996ba",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "Right. Again, for this to overflow we would need to exceed the size of the address space.",
      "parentUuid": "5eee4212_51bb04c1",
      "range": {
        "startLine": 239,
        "startChar": 11,
        "endLine": 239,
        "endChar": 73
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97e2846b_113f1c55",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 244,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "could overflow, but really calloc should fail.",
      "range": {
        "startLine": 244,
        "startChar": 19,
        "endLine": 244,
        "endChar": 41
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f239f41c_70ae3202",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 244,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "Yes, let\u0027s just let calloc fail instead of us in that case.",
      "parentUuid": "97e2846b_113f1c55",
      "range": {
        "startLine": 244,
        "startChar": 19,
        "endLine": 244,
        "endChar": 41
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed7d88cf_a6d8042d",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 244,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T21:53:26Z",
      "side": 1,
      "message": "sgtm. unsigned integer overflow isn\u0027t undefined.",
      "parentUuid": "f239f41c_70ae3202",
      "range": {
        "startLine": 244,
        "startChar": 19,
        "endLine": 244,
        "endChar": 41
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52b2dc73_469e7736",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 250,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "this could go below 0 (and underflow) due to untracked memory (can this happen due to estimate on line 306)?  Perhaps we should clamp to 0 (and track the underflow amount) - the technically correct method is the following, but not sure if an approximate method is better or adding an substantial 32GB symmetric offset to gAllocated and gAllocLimit (assuming we\u0027re 64b size_t).\n\nconst size_t size \u003d Malloc(malloc_usable_size)(mem);\ndo {\n  const size_t allocated \u003d atomic_load_explicit(\u0026gAllocated, memory_order_acquire);\n  const size_t newAllocated \u003d allocated \u003e size ? allocated - size : 0;\n} while (!atomic_compare_exchange_weak(\u0026gAllocated, allocated, newAllocated, memory_order_acq_rel));\n\nlimit_realloc and limit_posix_memalign need some modification to use this.",
      "range": {
        "startLine": 250,
        "startChar": 0,
        "endLine": 250,
        "endChar": 65
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "efb175e6_6f575537",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 250,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "As far as I know the value from stats.allocated is intended to be accurate and not an estimate (see jemalloc man page http://jemalloc.net/jemalloc.3.html). So it\u0027s not clear to me that we need any of that.",
      "parentUuid": "52b2dc73_469e7736",
      "range": {
        "startLine": 250,
        "startChar": 0,
        "endLine": 250,
        "endChar": 65
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e0fdfc6_c86fd997",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 250,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T21:53:26Z",
      "side": 1,
      "message": "if one is so sure that jemalloc is being used, i think jemalloc\u0027s arena hooks could be used to track memory usage as well.",
      "parentUuid": "efb175e6_6f575537",
      "range": {
        "startLine": 250,
        "startChar": 0,
        "endLine": 250,
        "endChar": 65
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28293609_037bf070",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 250,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T23:00:29Z",
      "side": 1,
      "message": "I found hooks_arena_new_hook but it doesn\u0027t look like it can be used to abort an allocation, so it isn\u0027t clear how useful it would be. It also wouldn\u0027t work with the hwasan allocator, either.",
      "parentUuid": "2e0fdfc6_c86fd997",
      "range": {
        "startLine": 250,
        "startChar": 0,
        "endLine": 250,
        "endChar": 65
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d56c3115_cab20a96",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "Since you might get more bytes allocated than you requested, you can pass the check_limit but actually wind up larger than the limit because the usable size is larger. The total bytes allocated should still be completely accurate though. Also, multiple threads allocating at the same time could push you past the limit.\n\nI would assume this is best effort, so maybe that\u0027s okay.",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4227e8d1_5e28b079",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "Yes, exactly.",
      "parentUuid": "d56c3115_cab20a96",
      "range": {
        "startLine": 255,
        "startChar": 19,
        "endLine": 255,
        "endChar": 24
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b242c2db_a2c29b8f",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 282,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "This check isn\u0027t correct. You need to do some manual checking here.\n\nSpecifically, if old_mem !\u003d nullptr and bytes \u003c\u003d malloc_usable_size(old_mem), then you could either make the realloc call, or do nothing and return the original pointer.",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f19c0e8_66e2de29",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 282,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "In the case where bytes \u003c old_usable_size we will underflow here and produce a large positive number equal to 2^ptrsize - (old_usable_size - bytes). This will cause the calculation in check_limit to overflow and have the effect of subtracting (old_usable_size - bytes) from the value of gAllocated, which will result in the intended behaviour. Maybe that\u0027s too subtle though?",
      "parentUuid": "b242c2db_a2c29b8f",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32739768_801996f5",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-13T16:53:04Z",
      "side": 1,
      "message": "After thinking about this for a bit, I think you should use the mallopt functionality rather than add a new function.",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b8c1228_e7d2747b",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-13T17:39:10Z",
      "side": 1,
      "message": "I considered that, but decided against it because the second argument to mallopt is an int and it\u0027s entirely possible that we\u0027ll want to set the limit to \u003e2GB on 64-bit machines. We could work around that by having the argument mean the number of pages or something like that, but it seems like that would be less clear than a separate function.\n\nAnother reason is that mallopt is exposed to the NDK, and there\u0027s no real benefit to exposing this function to the NDK; it could even cause compatibility problems if apps start using this function and the platform starts allocating more memory.",
      "parentUuid": "32739768_801996f5",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2043ba4d_e15e7073",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-11-14T03:31:41Z",
      "side": 1,
      "message": "Another option would be adding a new general-purpose mallopt2 with an improved signature. I\u0027m not worried about giving NDK applications being able to shoot themselves in the foot: they can already call things like sigaction(2).\n\nPersonally, though, I think a new function is fine. cferris, what makes you prefer mallopt?",
      "parentUuid": "3b8c1228_e7d2747b",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf8262ce_25ed3273",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "if you\u0027re adding new functionality, what about\n\nandroid_get_current_allocation()?",
      "parentUuid": "2043ba4d_e15e7073",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa15014f_a8c80626",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "It seems like a new function is the best option for now. Since it\u0027s a platform private function, we always have the option of exposing this as part of the NDK interface (either as a general-purpose function like mallopt or a specific one) later if there proves to be a need.\n\nAnother reason why I\u0027d prefer not to expose this functionality to the NDK is that it seems like it would require us to implement a separate allocator limiter in ndk_translation for the reasons mentioned in https://googleplex-android-review.git.corp.google.com/c/platform/vendor/unbundled_google/libs/ndk_translation/+/5471053 , and ideally bionic and ndk_translation should diverge as little as possible (unless we say that the effect of the function is optional for NDK users, but then, what would be the point of exposing the function?)\n\nahung, would that be a function for getting the allocation limit? There\u0027s no use case for that at present so it would basically be dead code.",
      "parentUuid": "cf8262ce_25ed3273",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36dbd3fc_01d248a3",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T21:53:26Z",
      "side": 1,
      "message": "could report it back in the dumpsys.  btw, has this been tested with debug malloc? e.g.\n\nlibc.debug.malloc.program",
      "parentUuid": "fa15014f_a8c80626",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da96cb04_31f7a331",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T23:00:29Z",
      "side": 1,
      "message": "\u003e could report it back in the dumpsys.\n\nIt\u0027s possible, but we can always just add the function if/when we add this to dumpsys.\n\n\u003e btw, has this been tested with debug malloc?\n\n$ adb shell LIBC_DEBUG_MALLOC_OPTIONS\u003dbacktrace  /data/nativetest64/bionic-unit-tests/bionic-unit-tests --gtest_filter\u003dmalloc.android_set_allocation_limit\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] Running 1 test from 1 test case (8 jobs).\n[    OK    ] malloc.android_set_allocation_limit (831 ms)\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] 1 test from 1 test case ran. (834 ms total)\n[   PASS   ] 1 test.",
      "parentUuid": "36dbd3fc_01d248a3",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a4b060d_3bff2b13",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-30T22:42:39Z",
      "side": 1,
      "message": "I would prefer that you make this a mallopt where the argument is the size in MB. That should allow you all the range you need.\n\nUnless there is a really strong reason to do this, we prefer not to add new functions. As soon as you add this, some app will use it. It has happened before and it will happen again. Leaving it as mallopt, if we do decide to nop it or change it in some way, we don\u0027t have to worry about much in the way of app compat. You would be surprised at the weird way apps link against things and then don\u0027t even use that function.\n\nAnd either way, this is exactly the kind of thing that mallopt was invented for.",
      "parentUuid": "da96cb04_31f7a331",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bafb5cb5_6d0149d7",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1130394
      },
      "writtenOn": "2018-11-30T22:55:31Z",
      "side": 1,
      "message": "\u003e  Leaving it as mallopt, if we do decide to nop it or change it in some way, we don\u0027t have to worry about much in the way of app compat. \n\nHow so? Suppose we want to ignore allocation limits in the future. In the mallopt case, you need to have a switch-case entry matching the allocation limit mallopt option and ignore it; in the android_set_allocation_limit case, we\u0027d end up with a little function that did nothing. I don\u0027t see how one is better than the other from that perspective. What am I missing?\n\nAs a rule of thumb, I tend to disfavor \"multiplexer\" functions like ioctl, mallopt, and prctl. Each multiplexer is effectively just a different ways of calling one of a family of functions, and this call mechanism is usually more awkward than a direct call to the functionality one needs.",
      "parentUuid": "6a4b060d_3bff2b13",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "164281b7_34554a4e",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-30T23:39:29Z",
      "side": 1,
      "message": "Moreover, android_set_allocation_limit *reduces* the risk of app compat issues due to it being in LIBC_PLATFORM (so you can\u0027t link to it accidentally from NDK apps).",
      "parentUuid": "bafb5cb5_6d0149d7",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f02439f_9e21029b",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 303,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2019-01-25T21:13:27Z",
      "side": 1,
      "message": "We don\u0027t like adding new functions (outside of new posix or new C standard functions), we are trying to keep the signature as close to any other libc as possible.\n\nAs mentioned above, mallopt is already the place where these kind of things are done.",
      "parentUuid": "bafb5cb5_6d0149d7",
      "range": {
        "startLine": 303,
        "startChar": 16,
        "endLine": 303,
        "endChar": 44
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a6c9881_ae3b9389",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1019050
      },
      "writtenOn": "2018-11-08T23:58:11Z",
      "side": 1,
      "message": "These mallctl calls are deeply tied to the implementation of the allocator. You can\u0027t use this because there are already two allocators in use for Q.\n\nInstead you should replace this with something like:\n\natomic_init(\u0026gAllocated, mallinfo().uordblks);\n\nAnd you\u0027ll have to deal with the fact that it\u0027s going to be close but not completely accurate unless the system isn\u0027t doing anything.",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1beda7e1_670f44fd",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-09T00:52:58Z",
      "side": 1,
      "message": "As best as I can tell, Scudo works by adding a library to an executable\u0027s DT_NEEDED that interposes the regular libc allocator. That means that none of bionic\u0027s malloc_dispatch mechanism actually comes into play when Scudo is in use.\n\nSo, what is the effect of calling android_set_allocation_limit() in a Scudo-enabled process? It seems like there would be no effect at all because this function only modifies globals that are ultimately unused in such a process. So if Scudo wants this function to work properly, it seems like it should also interpose that function.\n\nThat said, there has been a change to limitProcessMemory to make it check for Scudo and call its version of android_set_allocation_limit if it is present: https://android-review.googlesource.com/c/platform/frameworks/av/+/793077\n\nSo it seems like there will be nothing to do once Scudo is integrated into the media processes, but it might be a good idea to add an interceptor to Scudo in order to make sure that calling android_set_allocation_limit() has an effect and to simplify the implementation of limitProcessMemory a little.",
      "parentUuid": "3a6c9881_ae3b9389",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46935206_05c279f9",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 314,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "i\u0027ll need to check on Scudo :-).",
      "parentUuid": "1beda7e1_670f44fd",
      "range": {
        "startLine": 305,
        "startChar": 0,
        "endLine": 314,
        "endChar": 46
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a4e0c0c_0659f972",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 334,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T00:33:23Z",
      "side": 1,
      "message": "should this be all or none  (not sure if that would be more race-free)  Doesn\u0027t seem that WriteProtected is thread-safe...\n\ne.g. if (globals-\u003emalloc_dispatch.calloc \u003d\u003d nullptr \u0026\u0026 ... \u003d\u003d nullptr \u0026\u0026...) {\n}",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 334,
        "endChar": 5
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0d2a7a3_301c7086",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 334,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T21:18:58Z",
      "side": 1,
      "message": "This function is not intended to be thread safe, the intent is that it will only be called once at the start of the program before starting any threads. I can add a comment to make that clear.",
      "parentUuid": "7a4e0c0c_0659f972",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 334,
        "endChar": 5
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec02e2ff_10d8fa23",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 334,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2018-11-29T21:53:26Z",
      "side": 1,
      "message": "would prefer to make comments on the assumptions that are being made.  this logic is a bit weird, the selective replacement of functions.",
      "parentUuid": "a0d2a7a3_301c7086",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 334,
        "endChar": 5
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "207b0a0d_42e9ccfb",
        "filename": "libc/bionic/malloc_common.cpp",
        "patchSetId": 2
      },
      "lineNbr": 334,
      "author": {
        "id": 1067098
      },
      "writtenOn": "2018-11-29T23:00:29Z",
      "side": 1,
      "message": "Added comment. Unfortunately hooks make this code more complicated than I\u0027d like.",
      "parentUuid": "ec02e2ff_10d8fa23",
      "range": {
        "startLine": 319,
        "startChar": 0,
        "endLine": 334,
        "endChar": 5
      },
      "revId": "8fc5f37cd67cd2f6a363e643bdd72844c7d73752",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}